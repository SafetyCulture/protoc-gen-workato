{
  title: "My Workato Connector",

  # API key authentication example. See more examples at https://docs.workato.com/developing-connectors/sdk/guides/authentication.html
  connection: {
    fields: [
      {
        name: 'api_key',
        label: 'API Key',
        optional: false,
        control_type: 'password',
        hint: 'Get your <b>API key</b> <a href="https://app.example.com/account/api-tokens" target="_blank">here</a>.'
      }
    ],

    authorization: {
      type: 'api_key',

      apply: lambda do |connection|
        headers('Authorization': "Bearer #{connection['api_key']}")
      end
    },

    base_uri: lambda do
      "https://api-2.example.com"
    end
  },

  test: lambda do |_connection|
    get('/users/me')
  end,

  object_definitions: {  
    custom_action_input: {
      fields: lambda do |_connection, config_fields|
        verb = config_fields['verb']
        input_schema = parse_json(config_fields.dig('input', 'schema') || '[]')
        data_props =
          input_schema.map do |field|
            if config_fields['request_type'] == 'multipart' &&
              field['binary_content'] == 'true'
              field['type'] = 'object'
              field['properties'] = [
                { name: 'file_content', optional: false },
                {
                  name: 'content_type',
                  default: 'text/plain',
                  sticky: true
                },
                { name: 'original_filename', sticky: true }
              ]
            end
            field
          end
        data_props = call('make_schema_builder_fields_sticky', data_props)
        input_data =
          if input_schema.present?
            if input_schema.dig(0, 'type') == 'array' &&
              input_schema.dig(0, 'details', 'fake_array')
              {
                name: 'data',
                type: 'array',
                of: 'object',
                properties: data_props.dig(0, 'properties')
              }
            else
              { name: 'data', type: 'object', properties: data_props }
            end
          end
  
        [
          {
            name: 'path',
            hint: 'Base URI is <b>' \
            '{APP_BASE_URI}' \
            '</b> - path will be appended to this URI. Use absolute URI to ' \
            'override this base URI.',
            optional: false
          },
          if %w[post put patch].include?(verb)
            {
              name: 'request_type',
              default: 'json',
              sticky: true,
              extends_schema: true,
              control_type: 'select',
              pick_list: [
                ['JSON request body', 'json'],
                ['URL encoded form', 'url_encoded_form'],
                ['Mutipart form', 'multipart'],
                ['Raw request body', 'raw']
              ]
            }
          end,
          {
            name: 'response_type',
            default: 'json',
            sticky: false,
            extends_schema: true,
            control_type: 'select',
            pick_list: [['JSON response', 'json'], ['Raw response', 'raw']]
          },
          if %w[get options delete].include?(verb)
            {
              name: 'input',
              label: 'Request URL parameters',
              sticky: true,
              add_field_label: 'Add URL parameter',
              control_type: 'form-schema-builder',
              type: 'object',
              properties: [
                {
                  name: 'schema',
                  sticky: input_schema.blank?,
                  extends_schema: true
                },
                input_data
              ].compact
            }
          else
            {
              name: 'input',
              label: 'Request body parameters',
              sticky: true,
              type: 'object',
              properties:
                if config_fields['request_type'] == 'raw'
                  [{
                    name: 'data',
                    sticky: true,
                    control_type: 'text-area',
                    type: 'string'
                  }]
                else
                  [
                    {
                      name: 'schema',
                      sticky: input_schema.blank?,
                      extends_schema: true,
                      schema_neutral: true,
                      control_type: 'schema-designer',
                      sample_data_type: 'json_input',
                      custom_properties:
                        if config_fields['request_type'] == 'multipart'
                          [{
                            name: 'binary_content',
                            label: 'File attachment',
                            default: false,
                            optional: true,
                            sticky: true,
                            render_input: 'boolean_conversion',
                            parse_output: 'boolean_conversion',
                            control_type: 'checkbox',
                            type: 'boolean'
                          }]
                        end
                    },
                    input_data
                  ].compact
                end
            }
          end,
          {
            name: 'request_headers',
            sticky: false,
            extends_schema: true,
            control_type: 'key_value',
            empty_list_title: 'Does this HTTP request require headers?',
            empty_list_text: 'Refer to the API documentation and add ' \
            'required headers to this HTTP request',
            item_label: 'Header',
            type: 'array',
            of: 'object',
            properties: [{ name: 'key' }, { name: 'value' }]
          },
          unless config_fields['response_type'] == 'raw'
            {
              name: 'output',
              label: 'Response body',
              sticky: true,
              extends_schema: true,
              schema_neutral: true,
              control_type: 'schema-designer',
              sample_data_type: 'json_input'
            }
          end,
          {
            name: 'response_headers',
            sticky: false,
            extends_schema: true,
            schema_neutral: true,
            control_type: 'schema-designer',
            sample_data_type: 'json_input'
          }
        ].compact
      end
    },
  
    custom_action_output: {
      fields: lambda do |_connection, config_fields|
        response_body = { name: 'body' }
  
        [
          if config_fields['response_type'] == 'raw'
            response_body
          elsif (output = config_fields['output'])
            output_schema = call('format_schema', parse_json(output))
            if output_schema.dig(0, 'type') == 'array' &&
              output_schema.dig(0, 'details', 'fake_array')
              response_body[:type] = 'array'
              response_body[:properties] = output_schema.dig(0, 'properties')
            else
              response_body[:type] = 'object'
              response_body[:properties] = output_schema
            end
  
            response_body
          end,
          if (headers = config_fields['response_headers'])
            header_props = parse_json(headers)&.map do |field|
              if field[:name].present?
                field[:name] = field[:name].gsub(/\W/, '_').downcase
              elsif field['name'].present?
                field['name'] = field['name'].gsub(/\W/, '_').downcase
              end
              field
            end
  
            { name: 'headers', type: 'object', properties: header_props }
          end
        ].compact
      end
    },
  
    'api.tasks.v1.CreateTaskRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "name",
            label: "Name",
            type: "string",
            hint: "<p>The name of the task</p>",
            
            
            sticky: true,
            
          },
          {
            name: "sms_confirmation",
            label: "Sms Confirmation",
            type: "boolean",
            convert_input: "boolean_conversion",
            hint: "<p>Should send sms confirmation</p>",
            
            control_type: "checkbox",
            
            sticky: true,
            
          },
          {
            name: "sms_retries",
            label: "Sms Retries",
            type: "integer",
            convert_input: "integer_conversion",
            hint: "<p>Number of SMS retries</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.CreateTaskResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "id",
            label: "Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.GetTaskRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "id",
            label: "Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.GetTaskResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "task",
            label: "Task",
            type: "object",
            properties: object_definitions['api.tasks.v1.Task'],
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.Task': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "id",
            label: "Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
          {
            name: "name",
            label: "Name",
            type: "string",
            hint: "<p>The name of the task</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.UpdateTaskRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "id",
            label: "Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            control_type: "select",
            toggle_hint: "Select from list",
            toggle_field:   {
              name: "id",
              label: "Id",
              type: "string",
              hint: "<p>The ID of the task</p>",
              
              toggle_hint: "Use ID",
              
              sticky: true,
              
            },
            pick_list: "dynamic_api_tasks_v1_tasksservice_listtasks",
            sticky: true,
            
          },
          {
            name: "name",
            label: "Name",
            type: "string",
            hint: "<p>The name of the task</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.UpdateTaskResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
        ]
        definition
      end
    },
  
    'api.tasks.v1.DeleteTaskRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "id",
            label: "Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.DeleteTaskResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
        ]
        definition
      end
    },
  
    'api.tasks.v1.AddCommentRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "task_id",
            label: "Task Id",
            optional: false,
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
          {
            name: "comment",
            label: "Comment",
            type: "string",
            hint: "<p>The comment to add</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.AddCommentResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "comment_id",
            label: "Comment Id",
            type: "string",
            hint: "<p>The ID of the comment</p>",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.UpdateCommentRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "task_id",
            label: "Task Id",
            type: "string",
            hint: "<p>The ID of the task</p>",
            
            
            sticky: true,
            
          },
          {
            name: "comment_id",
            label: "Comment Id",
            type: "string",
            hint: "<p>The ID comment to update</p>",
            
            
            sticky: true,
            
          },
          {
            name: "comment",
            label: "Comment",
            type: "string",
            hint: "<p>The updated comment</p>",
            
            
            sticky: true,
            
          },
          {
            name: "timezone",
            label: "Timezone",
            type: "string",
            
            control_type: "select",
            toggle_hint: "Select from list",
            toggle_field:   {
              name: "timezone",
              label: "Timezone",
              type: "string",
              
              toggle_hint: "Use ID",
              
              sticky: true,
              
            },
            pick_list: "timezones",
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.UpdateCommentResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
        ]
        definition
      end
    },
  
    'api.tasks.v1.CustomActionRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
        ]
        data = get("/data/for_tasks/#{input['custom_field']}")
        data.map ...
      end
    },
  
    'api.tasks.v1.CustomActionResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
        ]
        definition
      end
    },
  
    'api.tasks.v1.TriggerTaskRequest': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "trigger",
            label: "Trigger",
            type: "string",
            hint: "<p>Trigger event to subscribe to.</p>",
            
            control_type: "select",
            
            pick_list: "enum_api_tasks_v1_triggertaskrequest_triggerevent",
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.TriggerTaskResponse': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "webhook_id",
            label: "Webhook Id",
            type: "string",
            
            
            sticky: true,
            
          },
          {
            name: "task_id",
            label: "Task Id",
            type: "string",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
    'api.tasks.v1.UnusedButIncluded': {
      fields: lambda do |connection, config_fields, object_definitions|
        definition = [
          {
            name: "abc",
            label: "Abc",
            type: "string",
            
            
            sticky: true,
            
          },
        ]
        definition
      end
    },
  
  },

  actions: {  
    custom_action: {
      title "Custom Action"
      subtitle: 'Build your own iAuditor action with a HTTP request',
  
      description: lambda do |object_value, _object_label|
        "<span class='provider'>" \
        "#{object_value[:action_name] || 'Custom action'}</span> in " \
        "<span class='provider'>iAuditor</span>"
      end,
  
      help: {
        body: 'Build your own iAuditor action with a HTTP request. ' \
        'The request will be authorized with your iAuditor connection.',
        learn_more_url: 'https://developer.safetyculture.com',
        learn_more_text: 'iAuditor API documentation'
      },
  
      config_fields: [
        {
          name: 'action_name',
          hint: "Give this action you're building a descriptive name, e.g. " \
          'create record, get record',
          default: 'Custom action',
          optional: false,
          schema_neutral: true
        },
        {
          name: 'verb',
          label: 'Method',
          hint: 'Select HTTP method of the request',
          optional: false,
          control_type: 'select',
          pick_list: %w[get post put patch options delete]
            .map { |verb| [verb.upcase, verb] }
        }
      ],
  
      input_fields: lambda do |object_definition|
        object_definition['custom_action_input']
      end,
  
      execute: lambda do |_connection, input|
        verb = input['verb']
        if %w[get post put patch options delete].exclude?(verb)
          error("#{verb.upcase} not supported")
        end
        path = input['path']
        data = input.dig('input', 'data') || {}
        if input['request_type'] == 'multipart'
          data = data.each_with_object({}) do |(key, val), hash|
            hash[key] = if val.is_a?(Hash)
                          [val[:file_content],
                          val[:content_type],
                          val[:original_filename]]
                        else
                          val
                        end
          end
        end
        request_headers = input['request_headers']
          &.each_with_object({}) do |item, hash|
          hash[item['key']] = item['value']
        end || {}
        request = case verb
                  when 'get'
                    get(path, data)
                  when 'post'
                    if input['request_type'] == 'raw'
                      post(path).request_body(data)
                    else
                      post(path, data)
                    end
                  when 'put'
                    if input['request_type'] == 'raw'
                      put(path).request_body(data)
                    else
                      put(path, data)
                    end
                  when 'patch'
                    if input['request_type'] == 'raw'
                      patch(path).request_body(data)
                    else
                      patch(path, data)
                    end
                  when 'options'
                    options(path, data)
                  when 'delete'
                    delete(path, data)
                  end.headers(request_headers)
        request = case input['request_type']
                  when 'url_encoded_form'
                    request.request_format_www_form_urlencoded
                  when 'multipart'
                    request.request_format_multipart_form
                  else
                    request
                  end
        response =
          if input['response_type'] == 'raw'
            request.response_format_raw
          else
            request
          end
          .after_error_response(/.*/) do |code, body, headers, message|
            error({ code: code, message: message, body: body, headers: headers }
              .to_json)
          end
  
        response.after_response do |_code, res_body, res_headers|
          {
            body: res_body ? call('format_response', res_body) : nil,
            headers: res_headers
          }
        end
      end,
  
      output_fields: lambda do |object_definition|
        object_definition['custom_action_output']
      end
    },
  
    "action_tasks": {
      title: "Tasks",
      subtitle: "Interact with Tasks in iAuditor",
      description: lambda do |input, picklist_label|
        "<span class='provider'>#{picklist_label['action_name'] || 'Interact with Tasks'}</span> in <span class='provider'>iAuditor</span>"
      end,
      help: lambda do |input, picklist_label|
        case input['action_name']
        when 'api_tasks_v1_tasksservice_createtask'
          {
            body: '<p>Create a new task from the supplied input.</p>
  
  <p>Allows the user to create a new task and this is a really long multiline description.</p>',
            learn_more_url: '',
            learn_more_text: ''
          }
        when 'api_tasks_v1_tasksservice_customaction'
          {
            body: '<p>Custom Action with custom code</p>',
            learn_more_url: '',
            learn_more_text: ''
          }
        when 'api_tasks_v1_tasksservice_deletetask'
          {
            body: '<p>Delete a task by ID</p>',
            learn_more_url: 'https://google.com',
            learn_more_text: 'Check out these docs to learn more'
          }
        when 'api_tasks_v1_tasksservice_gettask'
          {
            body: '<p>This description comes from the OpenAPI tag<br>
  abc<br>
  123</p>',
            learn_more_url: '',
            learn_more_text: ''
          }
        when 'api_tasks_v1_tasksservice_updatetask'
          {
            body: '<p>Update a task by ID<br>
  This hint includes a <a href="https://google.com" target="_blank">link</a></p>',
            learn_more_url: '',
            learn_more_text: ''
          }
        else
          {
            body: 'Tasks allow you to define work to be done an assign it to someone.',
            learn_more_url: 'https://google.com',
            learn_more_text: 'Learn more about tasks'
          }
        end
      end,
      config_fields: [
        {
          name: "action_name",
          label: "Action",
          type: "string",
          
          control_type: "select",
          
          pick_list: "action_name_tasks",
          sticky: true,
          
        },
        {
          name: "custom_field",
          type: "text",
          
          
          sticky: true,
          ngIf: "input['action'] == 'api_tasks_v1_tasksservice_customaction'",
          
        },
      ],
      input_fields: lambda do |object_definitions, connection, config_fields|
        case config_fields['action_name']
        when 'api_tasks_v1_tasksservice_createtask'
          object_definitions['api.tasks.v1.CreateTaskRequest']
        when 'api_tasks_v1_tasksservice_customaction'
          object_definitions['api.tasks.v1.CustomActionRequest']
        when 'api_tasks_v1_tasksservice_deletetask'
          object_definitions['api.tasks.v1.DeleteTaskRequest']
        when 'api_tasks_v1_tasksservice_gettask'
          object_definitions['api.tasks.v1.GetTaskRequest']
        when 'api_tasks_v1_tasksservice_updatetask'
          object_definitions['api.tasks.v1.UpdateTaskRequest']
        end
      end,
      execute: lambda do |connection, input, eis, eos, continue|
        case input['action_name']
        when 'api_tasks_v1_tasksservice_createtask'
          exclude_keys = ["custom_field"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          post("/v1/tasks").payload(body)
        when 'api_tasks_v1_tasksservice_customaction'
          exclude_keys = ["custom_field"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          # does a thing
        when 'api_tasks_v1_tasksservice_deletetask'
          exclude_keys = ["id","custom_field"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          delete("/v1/tasks/#{input['id']}").params(body)
        when 'api_tasks_v1_tasksservice_gettask'
          exclude_keys = ["id","custom_field"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          get("/v1/tasks/#{input['id']}").params(body)
        when 'api_tasks_v1_tasksservice_updatetask'
          exclude_keys = ["id","custom_field"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          put("/v1/tasks/#{input['id']}").payload(body)
        end
      end,
      output_fields: lambda do |object_definitions, connection, config_fields|
        case config_fields['action_name']
        when 'api_tasks_v1_tasksservice_createtask'
          object_definitions['api.tasks.v1.CreateTaskResponse']
        when 'api_tasks_v1_tasksservice_customaction'
          object_definitions['api.tasks.v1.CustomActionResponse']
        when 'api_tasks_v1_tasksservice_deletetask'
          object_definitions['api.tasks.v1.DeleteTaskResponse']
        when 'api_tasks_v1_tasksservice_gettask'
          object_definitions['api.tasks.v1.GetTaskResponse']
        when 'api_tasks_v1_tasksservice_updatetask'
          object_definitions['api.tasks.v1.UpdateTaskResponse']
        end
      end,
    },
  
    "action_task_comments": {
      title: "Task Comments",
      subtitle: "Interact with Task Comments in iAuditor",
      description: lambda do |input, picklist_label|
        "<span class='provider'>#{picklist_label['action_name'] || 'Interact with Task Comments'}</span> in <span class='provider'>iAuditor</span>"
      end,
      help: lambda do |input, picklist_label|
        case input['action_name']
        when 'api_tasks_v1_tasksservice_addcomment'
          {
            body: '<p>Add a comment to a task</p>',
            learn_more_url: 'https://google.com',
            learn_more_text: ''
          }
        when 'api_tasks_v1_tasksservice_updatecomment'
          {
            body: '<p>Update a comment on a task</p>',
            learn_more_url: '',
            learn_more_text: ''
          }
        else
          {
            body: '',
            learn_more_url: '',
            learn_more_text: ''
          }
        end
      end,
      config_fields: [
        {
          name: "action_name",
          label: "Action",
          type: "string",
          
          control_type: "select",
          
          pick_list: "action_name_task_comments",
          sticky: true,
          
        },
      ],
      input_fields: lambda do |object_definitions, connection, config_fields|
        case config_fields['action_name']
        when 'api_tasks_v1_tasksservice_addcomment'
          object_definitions['api.tasks.v1.AddCommentRequest']
        when 'api_tasks_v1_tasksservice_updatecomment'
          object_definitions['api.tasks.v1.UpdateCommentRequest']
        end
      end,
      execute: lambda do |connection, input, eis, eos, continue|
        case input['action_name']
        when 'api_tasks_v1_tasksservice_addcomment'
          exclude_keys = ["task_id"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          post("/v1/tasks/#{input['task_id']}/comment").payload(body)
        when 'api_tasks_v1_tasksservice_updatecomment'
          exclude_keys = ["task_id","comment_id"]
          body = input.select { |k, v| k != 'action_name' and not exclude_keys.include? k }
          put("/v1/tasks/#{input['task_id']}/comment/#{input['comment_id']}").payload(body)
        end
      end,
      output_fields: lambda do |object_definitions, connection, config_fields|
        case config_fields['action_name']
        when 'api_tasks_v1_tasksservice_addcomment'
          object_definitions['api.tasks.v1.AddCommentResponse']
        when 'api_tasks_v1_tasksservice_updatecomment'
          object_definitions['api.tasks.v1.UpdateCommentResponse']
        end
      end,
    },
  
  },

  # Dynamic webhook example. Subscribes and unsubscribes webhooks programmatically
  # see more at https://docs.workato.com/developing-connectors/sdk/guides/building-triggers/dynamic-webhook.html
  triggers: {  
      trigger_tasks: {
         title: 'Task Event',
  
         description: "<span class='provider'>Trigger for Task Event</span>",
  
         input_fields: lambda do |object_definitions|
           object_definitions['api.tasks.v1.TriggerTaskRequest']
         end,
  
         webhook_subscribe: lambda do |webhook_url, connection, input|
           result = post('/webhooks/v1/webhooks')
             .payload(
               url: webhook_url,
               trigger_events: ["#{input['trigger']}"]
             )
           result['webhook']
         end,
  
         webhook_notification: lambda do |input, payload|
           payload
         end,
  
         webhook_unsubscribe: lambda do |webhook|
           delete("/webhooks/v1/webhooks/#{webhook['webhook_id']}")
         end,
  
         dedup: lambda do |event|
           if event.has_key?('workflow_id')
             event['workflow_id'] + '@' + event['event']['date_triggered']
           elsif event.has_key?('webhook_id')
             event['webhook_id'] + '@' + event['event']['date_triggered']
           end
         end,
  
         output_fields: lambda do |object_definitions|
           object_definitions['api.tasks.v1.TriggerTaskResponse']
         end,
      },
  },

  pick_lists: {  
    "dynamic_api_tasks_v1_tasksservice_listtasks": lambda do    
      body = {}
      qparams = call('encode_array_to_query_params', body)
      resp = get("/v1/tasks?#{qparams}")
      resp['tasks'].pluck('name', 'id')
    end,
    "action_name_tasks": lambda do
      [
        ['Create task', 'api_tasks_v1_tasksservice_createtask'],
        ['Get a task', 'api_tasks_v1_tasksservice_gettask'],
        ['Update task', 'api_tasks_v1_tasksservice_updatetask'],
        ['Delete task', 'api_tasks_v1_tasksservice_deletetask'],
        ['Custom action', 'api_tasks_v1_tasksservice_customaction'],
      ]
    end,
    "action_name_task_comments": lambda do
      [
        ['Add comment', 'api_tasks_v1_tasksservice_addcomment'],
        ['Update comment', 'api_tasks_v1_tasksservice_updatecomment'],
      ]
    end,
    "enum_api_tasks_v1_triggertaskrequest_triggerevent": lambda do
      [
        ['Task Started', 'TRIGGER_EVENT_TASK_CREATED'],
        ['Task Updated', 'TRIGGER_EVENT_TASK_UPDATED'],
        ['Task Closed', 'TRIGGER_EVENT_TASK_CLOSED'],
        ['Task Deleted', 'TRIGGER_EVENT_TASK_DELETED'],
      ]
    end,
  },

  # Reusable methods can be called from object_definitions, picklists or actions
  # See more at https://docs.workato.com/developing-connectors/sdk/sdk-reference/methods.html
  methods: {  
    "encode_array_to_query_params": lambda do |val|
      val.each do |key, value|
        if (value.is_a? String) && (value[0] == '[') && (value[-1] == ']')
          val[key] = parse_json(value)
        end
      end
      val.encode_www_form
    end,
  
    # This method is for Custom action
    make_schema_builder_fields_sticky: lambda do |schema|
      schema.map do |field|
        if field['properties'].present?
          field['properties'] = call('make_schema_builder_fields_sticky',
                                     field['properties'])
        end
        field['sticky'] = true
  
        field
      end
    end,
  
    # Formats input/output schema to replace any special characters in name,
    # without changing other attributes (method required for custom action)
    format_schema: lambda do |input|
      input&.map do |field|
        if (props = field[:properties])
          field[:properties] = call('format_schema', props)
        elsif (props = field['properties'])
          field['properties'] = call('format_schema', props)
        end
        if (name = field[:name])
          field[:label] = field[:label].presence || name.labelize
          field[:name] = name
                         .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        elsif (name = field['name'])
          field['label'] = field['label'].presence || name.labelize
          field['name'] = name
                          .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        end
  
        field
      end
    end,
  
    # Formats payload to inject any special characters that previously removed
    format_payload: lambda do |payload|
      if payload.is_a?(Array)
        payload.map do |array_value|
          call('format_payload', array_value)
        end
      elsif payload.is_a?(Hash)
        payload.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/__[0-9a-fA-F]+__/) do |string|
            string.gsub(/__/, '').decode_hex.as_utf8
          end
          value = call('format_payload', value) if value.is_a?(Array) || value.is_a?(Hash)
          hash[key] = value
        end
      end
    end,
  
    # Formats response to replace any special characters with valid strings
    # (method required for custom action)
    format_response: lambda do |response|
      response = response&.compact unless response.is_a?(String) || response
      if response.is_a?(Array)
        response.map do |array_value|
          call('format_response', array_value)
        end
      elsif response.is_a?(Hash)
        response.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
          if value.is_a?(Array) || value.is_a?(Hash)
            value = call('format_response', value)
          end
          hash[key] = value
        end
      else
        response
      end
    end,
    "does_a_thing": lambda do |param_1, param_2|
      param_1 + param_2
    end,
    "does_another_thing": lambda do |param_1, param_2|
      get("/an/api/#{param_1}")
      .body(param_2)
    end,
  }
}
